! function(window) {
    ControlParticles = function(startPos, col, size, juggle, wobble) {
        this.Container_constructor(), this._positions = startPos || [], this._circlesArray = [], this._dotRadius = size || 3, this._dotCol = col || "#000fff", this._shouldJuggle = juggle || !1, this._shouldWobble = wobble || !1, this._isAnimating = !1, this._wobbleMax = .5, this.dampen = .9, this.maxScale = 1, this.minScale = .9, this._maxAlpha = 1, this._minAlpha = .7, this._surplusCircles = []
    };
    var _p = createjs.extend(ControlParticles, createjs.Container);
    _p.generate = function() {
        for (var i = 0; i < this._positions.length; i++) {
            var radius = .8 * this._positions[i].r,
                s = this.makeCircle(radius);
            this.addChild(s), s.x = this._positions[i].x, s.y = this._positions[i].y, s.alpha = 0, this._circlesArray.push(s), this._shouldWobble && (s.getChildAt(0).alpha = Math.random() * (this._maxAlpha - this._minAlpha) + this._minAlpha, createjs.Ticker.addEventListener("tick", s.doWobble))
        }
    }, _p.form = function(rad, time, seq) {
        for (var rad = rad || 20, time = time || .5, seq = seq || false, len = this._circlesArray.length, i = 0; len > i; i++) {
            var progDelay = i / len,
                randomStart = new createjs.Point(this._positions[i].x + Math.random() * rad * 2 - rad, this._positions[i].y + Math.random() * rad * 2 - rad);
            var startTime;
            var animSpeed;
            if (seq) { startTime = i/15; animSpeed = 0.25 } else { startTime = Math.random(); animSpeed = 0.5 };
            TweenLite.fromTo(this._circlesArray[i], animSpeed + .5 * time, {
                scaleX: 0,
                scaleY: 0,
                alpha: 0,
                x: randomStart.x,
                y: randomStart.y
            }, {
                scaleX: 1,
                scaleY: 1,
                alpha: 1,
                x: this._positions[i].x,
                y: this._positions[i].y,
                delay: startTime * progDelay * time,
                ease: Sine.easeOut
            })
        }
    }, _p.disperse = function(xOff, yOff, style, t, rad) {
        var style = style || "small",
            t = t || 1,
            rad = rad || 50;
        this._isAnimating = !0;
        for (var newPoint = new createjs.Point, i = 0; i < this._circlesArray.length; i++) {
            var randomFactorX = (i / this._circlesArray.length, Math.random() * rad * 2),
                randomFactorY = Math.random() * rad * 2;
            newPoint.x = this._circlesArray[i].x + randomFactorX - rad, newPoint.y = this._circlesArray[i].y + randomFactorY - rad, "small" == style && (TweenLite.to(this._circlesArray[i], t, {
                x: newPoint.x,
                y: newPoint.y,
                delay: t * Math.random() * .3,
                ease: Sine.easeIn
            }), TweenLite.to(this._circlesArray[i], t, {
                alpha: 0,
                scaleX: 0,
                scaleY: 0,
                delay: t * Math.random() * .3,
                ease: Linear.easeNone
            }))
        }
    }, _p.tick = function(t, density) {
		
        var t = t || 0.3,
			density = 7;
		
        this._isAnimating = !0;
		
		var firstPoint = new createjs.Point;
		
		firstPoint.x = this._circlesArray[0].x, firstPoint.y = this._circlesArray[0].y;
		
		var lastPointIndex = Math.ceil((this._circlesArray.length - density)/ density) * density;
		
        for (var newPoint = new createjs.Point, i = 0; i < lastPointIndex; i += density) {

            newPoint.x = this._circlesArray[i+density].x, newPoint.y = this._circlesArray[i+density].y;
			TweenLite.to(this._circlesArray[i], t, {
                x: newPoint.x,
                y: newPoint.y,
                delay: Math.random()*2,
                ease: Elastic.backIn
            })
        }
		
		TweenLite.to(this._circlesArray[lastPointIndex], t, {
        	x: firstPoint.x,
            y: firstPoint.y,
            delay: Math.random()*2,
            ease: Elastic.backIn
        });
		
    }, _p.makeCircle = function(radius) {
        var c = new createjs.Container,
            s = new createjs.Shape;
        s.name = "circ", s.vx = s.vy = s.vz = 0, c.addChild(s);
        var g = s.graphics,
            _dampen = this.dampen,
            _wobbleMax = this._wobbleMax,
            _maxAlpha = this._maxAlpha,
            _minAlpha = this._minAlpha,
            _maxScale = this.maxScale,
            _minScale = this.minScale,
            myRadius = radius || this._dotRadius;
        return c.doWobble = function(c) {
            return function() {
                var thisCircle = c.getChildAt(0);
                thisCircle.vx += .02 * Math.random() - .01, thisCircle.vy += .02 * Math.random() - .01, thisCircle.vz += .01 * Math.random() - .005, thisCircle.x += thisCircle.vx, thisCircle.y += thisCircle.vy, thisCircle.scaleX = thisCircle.scaleY += thisCircle.vz, thisCircle.alpha += thisCircle.vz, thisCircle.vx *= _dampen, thisCircle.vy *= _dampen, thisCircle.vz *= _dampen, thisCircle.x > _wobbleMax ? thisCircle.x = _wobbleMax : thisCircle.x < -_wobbleMax && (thisCircle.x = -_wobbleMax), thisCircle.y > _wobbleMax ? thisCircle.y = _wobbleMax : thisCircle.y < -_wobbleMax && (thisCircle.y = -_wobbleMax), thisCircle.scaleX > _maxScale ? thisCircle.scaleX = thisCircle.scaleY = _maxScale : thisCircle.scaleX < _minScale && (thisCircle.scaleX = thisCircle.scaleY = _minScale), thisCircle.alpha > _maxAlpha ? thisCircle.alpha = _maxAlpha : thisCircle.alpha < _minAlpha && (thisCircle.alpha = _minAlpha)
            }
        }(c), g.beginFill(this._dotCol), g.drawCircle(0, 0, myRadius), g.endFill(), c
    }, window.ControlParticles = createjs.promote(ControlParticles, "Container")
}(window);